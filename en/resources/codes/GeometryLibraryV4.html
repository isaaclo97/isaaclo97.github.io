<html lang="en">

<head>
	<!-- Meta Data -->
    <title>{{CODE}} Algorithm</title>
	<meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="ðŸ–¥ï¸ {{CODE}} algorithm. Discover the complete code for the {{CODE}} functionality, any doubt you can write me to solve it.">
	<meta name="author" content="Isaac Lozano Osorio" />
    <link rel="shortcut icon" href="../../../img/favicon.jpg" type="image/x-icon">
	<meta name="reply-to" content="i.loozano97@gmail.com">
	<link rev="made" href="mailto:i.loozano97@gmail.com">
	<meta name="robots" content="ALL">
	
	<link rel="alternate" href="https://isaaclo97.github.io/en/resources/codes/{{URL}}.html" hreflang="en" />
	<link rel="alternate" href="https://isaaclo97.github.io/resources/codes/{{URL}}.html" hreflang="es" />
	
	
	<meta property="og:url" content="https://isaaclo97.github.io/en/resources/codes/{{URL}}.html">
	<meta property="og:locale" content="en">
	<meta property="og:type" content="website">
	<meta property="og:title" content="{{CODE}} Algorithm">
	<meta property="og:description" content="ðŸ–¥ï¸ {{CODE}} algorithm. Discover the complete code for the {{CODE}} functionality, any doubt you can write me to solve it..">
	<meta property="article:publisher" content="https://www.facebook.com/isaac.lozanoosorio">
	<meta property="og:image" content="../../../img/favicon.jpg">
	<meta property="article:modified_time" content="2021-02-11T18:33:24+00:00">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:creator" content="@isaac_lozano_97">
	<meta name="twitter:site" content="@isaac_lozano_97">

    <!-- Stlylesheet -->
	<link href="../../../css/owl.carousel.css" rel='stylesheet' type='text/css' />
	<link href="../../../css/cubeportfolio.min.css" rel='stylesheet' type='text/css' />
	<link href="../../../css/simple-line-icons.css" rel='stylesheet' type='text/css' />
	<link href="../../../css/ionicons.min.css" rel='stylesheet' type='text/css' />		
    <link href="../../../css/bootstrap.min.css" rel='stylesheet' type='text/css' />
    <link href="../../../css/style1.css" rel='stylesheet' type='text/css' />	
    <link href="../../../css/style.css" rel="stylesheet" type="text/css" />
    <link href="../../../css/prism.css" rel='stylesheet' type='text/css' />


    <!-- Skin Color -->
    <link rel="stylesheet" href="../../../css/colors/red.css" id="color-skins" />
	
	<script src="../../../js/translate.js"></script>
	
</head>

<body>
    <script src="../../../js/prism.js"></script>

    <!--Start Header-->
    <header>
        <nav class="navbar navbar-default navbar-alt" role="navigation">
            <div class="container">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>

                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse" id="main-nav">
                    <ul class="nav navbar-nav  navbar-right">
                        <li><a href="../../../en/index.html">Index</a></li>
                        <li class="to-section"><a href="../../../en/index.html#data2">Projects</a></li>
                        <li class="to-section"><a href="../../../en/index.html#portfolio">Technologies</a></li>
                        <li class="to-section"><a href="../../../en/index.html#team">Who I am?</a></li>
                        <li class="to-section"><a href="../../../en/index.html#get-connected">Contact</a></li>
                        <li class="to-section"><a href="../../../en/blog.html">Blog</a></li>
						<li class="to-section"><a href="../../../en/ajedrez.html">Chess</a></li>
                        <li class="to-section"><a href="../../../en/programacion.html">Competitive programming</a></li>
						<li class="to-section">
						<a href="#" onclick="translateWeb('es');return false;"  style="display: inline-block;" title="EspaÃ±ol"><img src="../../../img/es.png" height="24" width="24" alt="es"></a>
						<a href="#" onclick="translateWeb('en');return false;"  style="display: inline-block;" title="English"><img src="../../../img/en.png" height="24" width="24" alt="en"></a>
						</li>
                    </ul>
                </div>
                <!-- /.navbar-collapse -->
            </div>
            <!-- /.container -->
        </nav>
    </header>
    <!--End Header-->
  <section id="quote" class="parallax-section-4">
            <div class="container">
                <div class="row wow fadeInUp">

                    <div class="col-lg-12 wow fadeInUp" style="z-index:3">
                        <div id="quote-slider" class="owl-carousel">
                            <div>
                                <blockquote>
                                    <span>Competitive Programming.</span>
                                </blockquote>
                                <h4 class="quote-author highlight">Isaac Lozano Osorio</h4>
                            </div>

                        </div>
                    </div>

                </div>
            </div>
        </section>

        <!-- Start Team Section -->
        <section id="team">
            <div class="container">

                <div class="col-md-12 text-center wow fadeInUp">
                    <h3 class="section-title">{{CODE}} Algorithm.</h3>
					 <p class="subheading wow fadeInUp">Any questions do not hesitate to contact.</p>
                </div>
                <pre><code class="language-cpp">#include &lt;bits/stdc++.h>
#define EPS 10e-9
using namespace std;

typedef long long ll;
typedef pair&lt;int, int> pii;
typedef vector&lt;int> vi;
#define FOR(i, a, b) for(int i = (a); i &lt; int(b); i++)
#define trav(i, v) for(auto &i : v)
#define has(c, e) ((c).find(e) != (c).end())
#define sz(c) int((c).size())
#define all(c) c.begin(), c.end()
#define debug(x) cerr &lt;&lt; #x &lt;&lt; ": " &lt;&lt; x &lt;&lt; endl;

typedef double T;
template&lt;class T>
struct P {
    T x, y;

    explicit P(T a = 0, T b = 0) : x(a), y(b) {
    }

    bool operator&lt;(P p) const {
        return tie(x, y) &lt; tie(p.x, p.y);
    }

    bool operator==(P p) const {
        return tie(x, y) == tie(p.x, p.y);
    }

    P operator+(P p) const {
        return P(x + p.x, y + p.y);
    }

    P operator-(P p) const {
        return P(x - p.x, y - p.y);
    }

    P operator*(T d) const {
        return P(x*d, y * d);
    }

    P operator/(T d) const {
        return P(x / d, y / d);
    }

    T dot(P p) const {
        return x * p.x + y * p.y;
    }

    T cross(P p) const {
        return x * p.y - y * p.x;
    }

    T cross(P a, P b) const {
        return (a - * this).cross(b - * this);
    }

    T dist2() const {
        return x * x + y*y;
    }

    double dist() const {
        return sqrt((double) dist2());
    }
    // angle to x-axis in interval [-pi, pi]

    double angle() const {
        return atan2(y, x);
    }

    P unit() const {
        return *this / dist();
    } // makes dist()=1

    P perp() const {
        return P(-y, x);
    } // rotates +90 degrees

    P normal() const {
        return perp().unit();
    }
    // returns P rotated a radians ccw around the origin

    P rotate(double a) const {
        return P(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a));
    }
};

template&lt;class P>
double lineDist(const P& a, const P& b, const P& p) {
    return (double) (b - a).cross(p - a) / (b - a).dist();
}
template&lt;class P>
double segDist(P& s, P& e, P& p) {
    if (s == e) return (p - s).dist();
    auto d = (e - s).dist2(), t = min(d, max(.0, (p - s).dot(e - s)));
    return ((p - s) * d - (e - s) * t).dist() / d;
}
template &lt;class P>
int segmentIntersection(const P& s1, const P& e1,
        const P& s2, const P& e2, P& r1, P& r2) {
    if (e1 == s1) {
        if (e2 == s2) {
            if (e1 == e2) {
                r1 = e1;
                return 1;
            }//all equal
            else return 0; //different P segments
        } else return segmentIntersection(s2, e2, s1, e1, r1, r2); //swap
    }
    //segment directions and separation
    P v1 = e1 - s1, v2 = e2 - s2, d = s2 - s1;
    auto a = v1.cross(v2), a1 = v1.cross(d), a2 = v2.cross(d);
    if (a == 0) { //if parallel
        auto b1 = s1.dot(v1), c1 = e1.dot(v1),
                b2 = s2.dot(v1), c2 = e2.dot(v1);
        if (a1 || a2 || max(b1, min(b2, c2)) > min(c1, max(b2, c2)))
            return 0;
        r1 = min(b2, c2) &lt; b1 ? s1 : (b2 &lt; c2 ? s2 : e2);
        r2 = max(b2, c2) > c1 ? e1 : (b2 > c2 ? s2 : e2);
        return 2 - (r1 == r2);
    }
    if (a &lt; 0) {
        a = -a;
        a1 = -a1;
        a2 = -a2;
    }
    if (0 &lt; a1 || a&lt;-a1 || 0 &lt; a2 || a&lt;-a2)
        return 0;
    r1 = s1 - v1 * a2 / a;
    return 1;


}
template &lt;class P>
bool segmentIntersectionQ(P s1, P e1, P s2, P e2) {
    if (e1 == s1) {
        if (e2 == s2) return e1 == e2;
        swap(s1, s2);
        swap(e1, e2);
    }
    P v1 = e1 - s1, v2 = e2 - s2, d = s2 - s1;
    auto a = v1.cross(v2), a1 = d.cross(v1), a2 = d.cross(v2);
    if (a == 0) { // parallel
        auto b1 = s1.dot(v1), c1 = e1.dot(v1),
                b2 = s2.dot(v1), c2 = e2.dot(v1);
        return !a1 && max(b1, min(b2, c2)) &lt;= min(c1, max(b2, c2));
    }
    if (a &lt; 0) {
        a = -a;
        a1 = -a1;
        a2 = -a2;
    }
    return (0 &lt;= a1 && a1 &lt;= a && 0 &lt;= a2 && a2 &lt;= a);
}

template &lt;class P>
int lineIntersection(const P& s1, const P& e1, const P& s2,
        const P& e2, P& r) {
    if ((e1 - s1).cross(e2 - s2)) { //if not parallell
        r = s2 - (e2 - s2)*(e1 - s1).cross(s2 - s1) / (e1 - s1).cross(e2 - s2);
        return 1;
    } else
        return -((e1 - s1).cross(s2 - s1) == 0 || s2 == e2);
}

template &lt;class P>
int sideOf(const P& s, const P& e, const P& p) {
    auto a = (e - s).cross(p - s);
    return (a > 0) - (a &lt; 0);
}

template &lt;class P>
int sideOf(const P& s, const P& e, const P& p, double eps) {
    auto a = (e - s).cross(p - s);
    double l = (e - s).dist() * eps;
    return (a > l) - (a &lt; -l);
}

template &lt;class P>
bool onSegment(const P& s, const P& e, const P& p) {
    P ds = p - s, de = p - e;
    return ds.cross(de) == 0 && ds.dot(de) &lt;= 0;
}

template &lt;class P>
P linearTransformation(const P& p0, const P& p1,
        const P& q0, const P& q1, const P& r) {
    P dp = p1 - p0, dq = q1 - q0, num(dp.cross(dq), dp.dot(dq));
    return q0 + P((r - p0).cross(num), (r - p0).dot(num)) / dp.dist2();
}

struct Angle {
    int x, y;
    int t;

    Angle(int x, int y, int t = 0) : x(x), y(y), t(t) {
    }

    Angle operator-(Angle b) const {
        return
        {
            x - b.x, y - b.y, t
        };
    }

    int quad() const {
        assert(x || y);
        if (y &lt; 0) return (x >= 0) + 2;
        if (y > 0) return (x &lt;= 0);
        return (x &lt;= 0) * 2;
    }

    Angle t90() const {
        return
        {
            -y, x, t + (quad() == 3)
        };
    }

    Angle t180() const {
        return
        {
            -x, -y, t + (quad() >= 2)
        };
    }

    Angle t360() const {
        return
        {
            x, y, t + 1
        };
    }
};

bool operator&lt;(Angle a, Angle b) {
    // add a.dist2() and b.dist2() to also compare distances
    return make_tuple(a.t, a.quad(), a.y * (ll) b.x) &lt;
            make_tuple(b.t, b.quad(), a.x * (ll) b.y);
}
// Given two Ps, this calculates the smallest angle between
// them, i.e., the angle that covers the defined line segment.

pair&lt;Angle, Angle> segmentAngles(Angle a, Angle b) {
    if (b &lt; a) swap(a, b);
    return (b &lt; a.t180() ?
            make_pair(a, b) : make_pair(b, a.t360()));
}

Angle operator+(Angle a, Angle b) { // P a + vector b
    Angle r(a.x + b.x, a.y + b.y, a.t);
    if (a.t180() &lt; r) r.t--;
    return r.t180() &lt; a ? r.t360() : r;
}

Angle angleDiff(Angle a, Angle b) { // angle b - angle a
    int tu = b.t - a.t;
    a.t = b.t;
    return
    {
        a.x * b.x + a.y * b.y, a.x * b.y - a.y * b.x, tu - (b &lt; a)
    };
}

template &lt;class P>
bool circleIntersection(P a, P b, double r1, double r2,
        pair&lt;P, P>* out) {
    P delta = b - a;
    assert(delta.x || delta.y || r1 != r2);
    if (!delta.x && !delta.y) return false;
    double r = r1 + r2, d2 = delta.dist2();
    double p = (d2 + r1 * r1 - r2 * r2) / (2.0 * d2);
    double h2 = r1 * r1 - p * p*d2;
    if (d2 > r * r || h2 &lt; 0) return false;
    P mid = a + delta*p, per = delta.perp() * sqrt(h2 / d2);
    *out = {mid + per, mid - per};
    return true;
}

template &lt;class P>
pair&lt;P, P> circleTangents(const P &p, const P &c, double r) {
    P a = p - c;
    double x = r * r / a.dist2(), y = sqrt(x - x * x);
    return make_pair(c + a * x + a.perp() * y, c + a * x - a.perp() * y);
}

template &lt;class P>
double ccRadius(const P& A, const P& B, const P& C) {
    return (B - A).dist()*(C - B).dist()*(A - C).dist() /
            abs((B - A).cross(C - A)) / 2;
}
template &lt;class P>
P ccCenter(const P& A, const P& B, const P& C) {
    P b = C - A, c = B - A;
    return A + (b * c.dist2() - c * b.dist2()).perp() / b.cross(c) / 2;
}
template &lt;class P>
pair&lt;double, P> mec2(vector&lt;P>& S, P a, P b, int n) {
    double hi = INFINITY, lo = -hi;

    FOR(i, 0, n) {
        auto si = (b - a).cross(S[i] - a);
        if (si == 0) continue;
        P m = ccCenter(a, b, S[i]);
        auto cr = (b - a).cross(m - a);
        if (si &lt; 0) hi = min(hi, cr);
        else lo = max(lo, cr);
    }
    double v = (0 &lt; lo ? lo : hi &lt; 0 ? hi : 0);
    P c = (a + b) / 2 + (b - a).perp() * v / (b - a).dist2();
    return
    {
        (a - c).dist2(), c
    };
}
template &lt;class P>
pair&lt;double, P> mec(vector&lt;P>& S, P a, int n) {
    random_shuffle(S.begin(), S.begin() + n);
    P b = S[0], c = (a + b) / 2;
    double r = (a - c).dist2();
    FOR(i, 1, n) if ((S[i] - c).dist2() > r * (1 + 1e-8)) {
        tie(r, c) = (n == sz(S) ?
                mec(S, S[i], i) : mec2(S, a, S[i], i));
    }
    return
    {
        r, c
    };
}
template &lt;class P>
pair&lt;double, P> enclosingCircle(vector&lt;P> S) {
    assert(!S.empty());
    auto r = mec(S, S[0], sz(S));
    return
    {
        sqrt(r.first), r.second
    };
}

template &lt;class It, class P>
bool insidePolygon(It begin, It end, const P& p,
        bool strict = true) {
    int n = 0; //number of isects with line from p to (inf,p.y)
    for (It i = begin, j = end - 1; i != end; j = i++) {
        //if p is on edge of polygon
        if (onSegment(*i, *j, p)) return !strict;
        //or: if (segDist(*i, *j, p) &lt;= epsilon) return !strict;
        //increment n if segment intersects line from p
        n += (max(i->y, j->y) > p.y && min(i->y, j->y) &lt;= p.y &&
                ((*j - *i).cross(p - *i) > 0) == (i->y &lt;= p.y));
    }
    return n & 1; //inside if odd number of intersections
}

template &lt;class T>
T polygonArea2(vector&lt;P&lt;T>>&v) {
    T a = v.back().cross(v[0]);
    FOR(i, 0, sz(v) - 1) a += v[i].cross(v[i + 1]);
    return a;
}

template &lt;class P>
P polygonCenter(vector&lt;P>& v) {
    auto i = v.begin(), end = v.end(), j = end - 1;
    P res{0, 0};
    double A = 0;
    for (; i != end; j = i++) {
        res = res + (*i + *j) * j->cross(*i);
        A += j->cross(*i);
    }
    return res / A / 3;
}
template &lt;class P>
vector&lt;P> polygonCut(const vector&lt;P>& poly, P s, P e) {
    vector&lt;P> res;

    FOR(i, 0, sz(poly)) {
        P cur = poly[i], prev = i ? poly[i - 1] : poly.back();
        bool side = s.cross(e, cur) &lt; 0;
        if (side != (s.cross(e, prev) &lt; 0)) {
            res.emplace_back();
            lineIntersection(s, e, cur, prev, res.back());
        }
        if (side)
            res.push_back(cur);
    }
    return res;
}

template &lt;class P>
int insideHull2(const vector&lt;P>& H, int L, int R, const P& p) {
    int len = R - L;
    if (len == 2) {
        int sa = sideOf(H[0], H[L], p);
        int sb = sideOf(H[L], H[L + 1], p);
        int sc = sideOf(H[L + 1], H[0], p);
        if (sa &lt; 0 || sb &lt; 0 || sc &lt; 0) return 0;
        if (sb == 0 || (sa == 0 && L == 1) || (sc == 0 && R == sz(H)))
            return 1;
        return 2;
    }
    int mid = L + len / 2;
    if (sideOf(H[0], H[mid], p) >= 0)
        return insideHull2(H, mid, R, p);
    return insideHull2(H, L, mid + 1, p);
}
template &lt;class P>
int insideHull(const vector&lt;P>& hull, const P& p) {
    if (sz(hull) &lt; 3) return onSegment(hull[0], hull.back(), p);
    else return insideHull2(hull, 1, sz(hull), p);
}

ll sgn(ll a) {
    return (a > 0) - (a &lt; 0);
}
template &lt;class P>
struct HullIntersection {
    int N;
    vector&lt;P> p;
    vector&lt;pair&lt;P, int>> a;

    HullIntersection(const vector&lt;P>& ps) : N(sz(ps)), p(ps) {
        p.insert(p.end(), all(ps));
        int b = 0;
        FOR(i, 1, N) if (P{p[i].y, p[i].x}
            &lt; P
            {
                p[b].y, p[b].x
            }) b = i;

        FOR(i, 0, N) {
            int f = (i + b) % N;
            a.emplace_back(p[f + 1] - p[f], f);
        }
    }

    int qd(P p) {
        return (p.y &lt; 0) ? (p.x >= 0) + 2
                : (p.x &lt;= 0) * (1 + (p.y &lt;= 0));
    }

    int bs(P dir) {
        int lo = -1, hi = N;
        while (hi - lo > 1) {
            int mid = (lo + hi) / 2;
            if (make_pair(qd(dir), dir.y * a[mid].first.x) &lt;
                    make_pair(qd(a[mid].first), dir.x * a[mid].first.y))
                hi = mid;
            else lo = mid;
        }
        return a[hi % N].second;
    }

    bool isign(P a, P b, int x, int y, int s) {
        return sgn(a.cross(p[x], b)) * sgn(a.cross(p[y], b)) == s;
    }

    int bs2(int lo, int hi, P a, P b) {
        int L = lo;
        if (hi &lt; lo) hi += N;
        while (hi - lo > 1) {
            int mid = (lo + hi) / 2;
            if (isign(a, b, mid, L, -1)) hi = mid;
            else lo = mid;
        }
        return lo;
    }

    pii isct(P a, P b) {
        int f = bs(a - b), j = bs(b - a);
        if (isign(a, b, f, j, 1)) return {
            -1, -1
        };
        int x = bs2(f, j, a, b) % N,
                y = bs2(j, f, a, b) % N;
        if (a.cross(p[x], b) == 0 &&
                a.cross(p[x + 1], b) == 0) return {
            x, x
        };
        if (a.cross(p[y], b) == 0 &&
                a.cross(p[y + 1], b) == 0) return {
            y, y
        };
        if (a.cross(p[f], b) == 0) return {
            f, -1
        };
        if (a.cross(p[j], b) == 0) return {
            j, -1
        };
        return
        {
            x, y
        };
    }
};


int lxsol,lysol,rxsol,rysol;
int hasIntersectQuadrangles(int lx, int ly, int rx, int ry, int la, int lb, int ra, int rb) {
    lx = lxsol = max(lx, la);
    ly = lysol = max(ly, lb);
    rx = rxsol = min(rx, ra);
    ry = rysol = min(ry, rb);
    return lx &lt; rx && ly &lt; ry;
}

bool canFormQuadrangle(double a, double b, double c,double d) {
  return (a + b + c> d) && (a + c + d > b) && (b + c + d > a) && (a+b+d>c); }

bool canFormTriangle(double a, double b, double c) {
  return (a + b > c) && (a + c > b) && (b + c > a); }

double perimeter(double ab, double bc, double ca) {
  return ab + bc + ca; }

double area(double ab, double bc, double ca) {
  // Heron's formula
  double s = 0.5 * perimeter(ab, bc, ca);
  return sqrt(s) * sqrt(s - ab) * sqrt(s - bc) * sqrt(s - ca); }

double rInCircle(double ab, double bc, double ca) {
  double per = perimeter(ab, bc, ca);
  if(per==0) return 0;
  return area(ab, bc, ca) / (0.5 * per); }

template &lt;class P>
double cross(P o, P a, P b) {
    return (a.x-o.x)*(b.y-o.y) - (a.y-o.y)*(b.x-o.x);
}
template &lt;class P>
double cross2(P a, P b) {
    return a.x * b.y - a.y * b.x;
}

template &lt;class P>
double dist(P p1, P p2) {
  return hypot(p1.x - p2.x, p1.y - p2.y); }

template &lt;class P>
double perimeter(const vector&lt;P> &Pa) {
  double result = 0.0;
  for (int i = 0; i &lt; (int)Pa.size()-1; i++)
    result += dist(Pa[i], Pa[i+1]);
  return result; }

template &lt;class P>
vector&lt;P> CH(vector&lt;P> Pa){
    vector&lt;P> res;
    sort(Pa.begin(),Pa.end());
    int n = Pa.size();
    int m=0;
    for (int i=0;i&lt;n;i++){
        while (m>1&&cross(res[m-2], res[m-1], Pa[i]) &lt;= 0)res.pop_back(),m--;
        res.push_back(Pa[i]),m++;
    }
    for (int i = n-1, t = m+1; i >= 0; i--) {
        while (m>=t&&cross(res[m-2], res[m-1], Pa[i]) &lt;= 0)res.pop_back(),m--;
        res.push_back(Pa[i]),m++;
    }
    return res;
}

double calc_area(vector&lt;P&lt;double>> Pa) {
    double ans = 0;
    for(int i = 0; i &lt; (int)Pa.size()-1; i++)
        ans += Pa[i].x*Pa[i+1].y - Pa[i].y*Pa[i+1].x;
    return fabs(ans)/2.0;
}
template &lt;class P>
P centroid(vector&lt;P> g)		//center of mass
{
    double cx = 0.0, cy = 0.0;
    for(unsigned int i = 0; i &lt; g.size() - 1; i++)
    {
        double x1 = g[i].x, y1 = g[i].y;
        double x2 = g[i+1].x, y2 = g[i+1].y;

        double f = x1 * y2 - x2 * y1;
        cx += (x1 + x2) * f;
        cy += (y1 + y2) * f;
    }
    double res = calc_area(g);		//remove abs
    cx /= 6.0 * res;
    cy /= 6.0 * res;
    return P(cx, cy);
}

struct line {
    double a, b, c;
};

// the answer is stored in the third parameter (pass by reference)
template &lt;class P>
void pointsToLine(P p1, P p2, line &l) {
    if (fabs(p1.x - p2.x) &lt; EPS) { // vertical line is fine
        l.a = 1.0;
        l.b = 0.0;
        l.c = -p1.x; // default values
    } else {
        l.a = -(double) (p1.y - p2.y) / (p1.x - p2.x);
        l.b = 1.0; // IMPORTANT: we fix the value of b to 1.0
        l.c = -(double) (l.a * p1.x) - p1.y;
    }
}

struct vec {
    double x, y;

    vec(double _x, double _y) : x(_x), y(_y) {
    }
};
template &lt;class P>
vec toVec(P a, P b) {
    return vec(b.x - a.x, b.y - a.y);
}

double dot(vec a, vec b) {
    return (a.x * b.x + a.y * b.y);
}

double norm_sq(vec v) {
    return v.x * v.x + v.y * v.y;
}

vec scale(vec v, double s) { // nonnegative s = [&lt;1 .. 1 ..>1]
    return vec(v.x * s, v.y * s);
}// shorter.same.longer

template &lt;class P>
P translate(P p, vec v) { // translate p according to v
    return P(p.x + v.x, p.y + v.y);
}
template &lt;class P>
double distToLine(P p, P a, P b, P &c) {
    // formula: c = a + u * ab
    vec ap = toVec(a, p), ab = toVec(a, b);
    double u = dot(ap, ab) / norm_sq(ab);
    c = translate(a, scale(ab, u)); // translate a to c
    return dist(p, c);
}
template &lt;class P>
double distToLineSegment(P p, P a, P b, P &c) {
    vec ap = toVec(a, p), ab = toVec(a, b);
    double u = dot(ap, ab) / norm_sq(ab);
    if (u &lt; 0.0) {
        c = P(a.x, a.y); // closer to a
        return dist(p, a);
    }
    if (u > 1.0) {
        c = P(b.x, b.y); // closer to b
        return dist(p, b);
    }
    return distToLine(p, a, b, c);
} // run distToLine as above

template &lt;class P>
bool areIntersect(line l1, line l2, P &p) {
    int den = l1.a * l2.b - l1.b * l2.a;
    if (!den) return false; //same line or parallel
    p.x = l1.c * l2.b - l1.b * l2.c;
    if (p.x) p.x /= den;
    p.y = l1.a * l2.c - l1.c * l2.a;
    if (p.y) p.y /= den;
    return true;
}
template &lt;class P>
int insideCircle(P p, P c, double r) { // all integer version
    double dx = p.x - c.x, dy = p.y - c.y;
    double Euc = dx * dx + dy * dy, rSq = r * r; // all integer
    return Euc &lt; rSq ? 0 : Euc == rSq ? 1 : 2;
} //inside/border/outside

template &lt;class P>
bool circle2PtsRad(P p1, P p2, double r, P &c) {
    double d2 = (p1.x - p2.x) * (p1.x - p2.x) +
            (p1.y - p2.y) * (p1.y - p2.y);
    double det = r * r / d2 - 0.25;
    if (det &lt; 0.0) return false;
    double h = sqrt(det);
    c.x = (p1.x + p2.x) * 0.5 + (p1.y - p2.y) * h;
    c.y = (p1.y + p2.y) * 0.5 + (p2.x - p1.x) * h;
    return true;
}
// returns 1 if there is a circumCenter center, returns 0 otherwise
// if this function returns 1, ctr will be the circumCircle center
// and r is the same as rCircumCircle

template &lt;class P>
int circumCircle(P p1, P p2, P p3, P& ctr,double &r) {
    double a = p2.x - p1.x, b = p2.y - p1.y;
    double c = p3.x - p1.x, d = p3.y - p1.y;
    double e = a * (p1.x + p2.x) + b * (p1.y + p2.y);
    double f = c * (p1.x + p3.x) + d * (p1.y + p3.y);
    double g = 2.0 * (a * (p3.y - p2.y) - b * (p3.x - p2.x));
    if (fabs(g) &lt; EPS) return 0;
    ctr.x = (d * e - b * f) / g;
    ctr.y = (a * f - c * e) / g;
    r = dist(p1, ctr); // r = distance from center to 1 of the 3 points
    return 1;
}
// returns true if Pd is inside the circumCircle defined by a,b,c

template &lt;class P>
int inCircumCircle(P a, P b, P c, P d) {
    return (a.x - d.x) * (b.y - d.y) * ((c.x - d.x) * (c.x - d.x)
            + (c.y - d.y) * (c.y - d.y)) +
            (a.y - d.y) * ((b.x - d.x) * (b.x - d.x) + (b.y - d.y)
            * (b.y - d.y)) * (c.x - d.x) +
            ((a.x - d.x) * (a.x - d.x) + (a.y - d.y) * (a.y - d.y)
            ) * (b.x - d.x) * (c.y - d.y) -
            ((a.x - d.x) * (a.x - d.x) + (a.y - d.y) * (a.y - d.y)
            ) * (b.y - d.y) * (c.x - d.x) -
            (a.y - d.y) * (b.x - d.x) * ((c.x - d.x) * (c.x - d.x)
            + (c.y - d.y) * (c.y - d.y)) -
            (a.x - d.x) * ((b.x - d.x) * (b.x - d.x) + (b.y - d.y)
            * (b.y - d.y)) * (c.y - d.y) > 0 ? 1 : 0;
}

double cross(vec a, vec b) {
    return a.x * b.y - a.y * b.x;
}
// note: to accept collinear points, we have to change the > 0
// returns true if Pr is on the left side of line pq
template &lt;class P>
bool ccw(P p, P q, P r) {
    return cross(toVec(p, q), toVec(p, r)) > 0;
}
// returns true if Pr is on the same line as the line pq
template &lt;class P>
bool collinear(P p, P q, P r) {
    return fabs(cross(toVec(p, q), toVec(p, r))) &lt; EPS;
}
template &lt;class P>
bool isConvex(const vector&lt;P> &Pa) {
    int sz = (int) Pa.size();
    if (sz &lt;= 3) return false;
    bool isLeft = ccw(Pa[0], Pa[1], Pa[2]);
    for (int i = 1; i &lt; sz - 1; i++)
        if (ccw(Pa[i], Pa[i + 1], Pa[(i + 2) == sz ? 1 : i + 2]) != isLeft)
            return false;
    return true;
}
template &lt;class P>
double polygonDiameter(const vector&lt;P>& pt) {
    double ret = 1e+60;
    P aux;
    int n =  pt.size()-1; //just end added
	if (n &lt;= 2) return 0;
    for (int i = 0, j = 0; i &lt;n; i++) {
            while (cross(pt[i], pt[i+1], pt[j+1]) >= cross(pt[i], pt[i+1], pt[j]))
                j = (j+1)%n;
            double dist = distToLineSegment(pt[j], pt[i], pt[i+1],aux);
            ret = min(ret, dist);
        }
    return ret;
}
int main()
{
    int n,r;
    while(scanf("%d%d",&n,&r)==2)
    {
        vector&lt;P&lt;double>> Pa;
        double x,y;
        for(int i=0; i&lt;n;i++)
        {
            scanf("%lf%lf",&x,&y); Pa.push_back(P&lt;double>{x,y});
        }
        vector&lt;P&lt;double>> res = CH(Pa);
        double sol = polygonDiameter(res);
        printf("%.17lf\n",sol);
    }
    return 0;
}
</code></pre>
            </div>
        </section>
         


        <!-- Start Get Connected -->
        <section id="get-connected" class="parallax-section-6">
            <div class="container">

                <div class="col-md-12 text-center">
                    <h3 class="section-title white wow fadeInUp">Don't miss anything.</h3>
                    <p class="subheading grey wow fadeInUp">Keep in touch with <span class="highlight">Isaac Lozano Osorio</span>!</p>
                </div>

                <div class="row text-center wow fadeInUp">
                    <ul class="connected-icons text-center">

                        <li class="connected-icon">
                            <a target="_blank" href="https://twitter.com/isaac_lozano_97">
                                <span class="icon icon-social-twitter size-6x"></span>
                                <h4 class="white">Twitter</h4>
                                <span class="grey">Follow me</span>
                            </a>
                        </li>

                        <li class="connected-icon">
                            <a target="_blank" href="https://www.facebook.com/isaac.lozanoosorio">
                                <span class="icon icon-social-facebook size-6x"></span>
                                <h4 class="white">Facebook</h4>
                                <span class="grey">Follow me</span>
                            </a>
                        </li>

                        <li class="connected-icon">
                            <a target="_blank" href="https://github.com/isaaclo97">
                                <span class="icon ion-social-octocat size-6x"></span>
                                <h4 class="white">GitHub</h4>
                                <span class="grey">Do you want to see my projects?</span>
                            </a>
                        </li>

                        <li class="connected-icon">
                            <a target="_blank" href="mailto:i.loozano97@gmail.com">
                                <span class="icon icon-envelope-open size-6x"></span>
                                <h4 class="white">Email</h4>
                                <span class="grey">i.loozano97@gmail.com</span>
                            </a>
                        </li>

                    </ul>
                </div>

            </div>
        </section>
        <!-- End Get Connected -->

        <!-- Start Footer 1 -->
        <footer id="footer">

            <div class="footer-copyright">
                <div class="container">
                    <div class="row">

                        <div class="col-md-6 col-sm-12">
                            <p>Â© 2018-2021 Isaac Lozano Osorio. All Rights Reserved. </p>
                        </div>
                        <div class="col-md-6 col-sm-12">
                            <ul id="social-icons">
                                <li><a target="_blank" href="https://github.com/isaaclo97"><i class="icon ion-social-twitter"></i></a></li>
                                <li><a target="_blank" href="https://www.facebook.com/isaac.lozanoosorio"><i class="icon ion-social-facebook"></i></a></li>
                                <li><a target="_blank" href="https://github.com/isaaclo97"><i class="icon ion-social-octocat"></i></a></li>
                                <li><a target="_blank" href="mailto:i.loozano97@gmail.com"><i class="icon ion-android-drafts"></i></a></li>
                            </ul>
                        </div>


                    </div>
                </div>
            </div>
            <!-- End Footer Copyright -->

        </footer>
        <!-- End Footer 1 -->

        <!-- Start Back To Top -->
        <a id="back-to-top"><i class="icon ion-chevron-up"></i></a>
        <!-- End Back To Top -->

    </div>
    <!-- End Site Wrapper -->

    <!-- jQuery -->
    <script src="../../../js/plugins/jquery.min.js"></script>
    <script src="../../../js/plugins/moderniz.min.js"></script>
    <script src="../../../js/plugins/smoothscroll.min.js"></script>
    <script src="../../../js/plugins/revslider.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/plugins/waypoints.min.js"></script>
    <script src="../../../js/plugins/parallax.min.js"></script>
    <script src="../../../js/plugins/easign1.3.min.js"></script>
    <script src="../../../js/plugins/cubeportfolio.min.js"></script>
    <script src="../../../js/plugins/owlcarousel.min.js"></script>
    <script src="../../../js/plugins/wow.min.js"></script>
    <script src="../../../js/plugins/counterup.min.js"></script>
    <script src="../../../js/scripts.js"></script>
    <script src="../../../js/bars.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://cdn.datatables.net/1.10.16/js/jquery.dataTables.min.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://cdn.datatables.net/1.10.16/js/dataTables.bootstrap.min.js"></script>
     <script type="text/javascript" charset="UTF-8" src="../../../load.js"></script>
    
    <script>
        (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-69918439-1', 'auto');
        ga('send', 'pageview');
    </script>

    <!--Start Cookie Script-->
    <script type="text/javascript" charset="UTF-8" src="https://cookie-script.com/s/eccbdbc38f31ea25d1b3265195902907.js"></script>
    <!--End Cookie Script-->

</body>

</html>